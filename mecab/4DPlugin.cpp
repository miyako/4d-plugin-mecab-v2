/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : MeCab
 #	author : miyako
 #	2018/12/11
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define DEFAULT_DICNAME "ipadic"

std::mutex mutexModel; /* gModel,gModelPath,gDicDir,gUserDics */

MeCab::Model *gModel = NULL;
std::string gModelPath;
std::string gDicDir;
std::vector<std::string> gUserDics;

void convert_userdic_to_hfs(std::string& dicdir)
{
#if VERSIONMAC
    /* convert to HFS */
    NSString *path_p = [[NSString alloc]initWithUTF8String:dicdir.c_str()];
    if(path_p)
    {
        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path_p, kCFURLPOSIXPathStyle, false);
        if(url)
        {
            NSString *path_h = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
            dicdir = [path_h UTF8String];
            [path_h release];
            [url release];
        }
        [path_p release];
    }
#endif
}

void convert_userdic_to_posix(std::string& dicdir)
{
#if VERSIONMAC
    /* convert HFS to POSIX */
    NSString *path_h = [[NSString alloc]initWithUTF8String:dicdir.c_str()];
    if(path_h)
    {
        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path_h, kCFURLHFSPathStyle, false);
        if(url)
        {
            NSString *path_p = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
            dicdir = [path_p UTF8String];
            [path_p release];
            [url release];
        }
        [path_h release];
    }
#endif
}

void convert_dicdir_to_hfs(std::string& dicdir)
{
#if VERSIONMAC
    /* convert to HFS */
    NSString *path_p = [[NSString alloc]initWithUTF8String:dicdir.c_str()];
    if(path_p)
    {
        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path_p, kCFURLPOSIXPathStyle, true);
        if(url)
        {
            NSString *path_h = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
            dicdir = [path_h UTF8String];
            [path_h release];
            [url release];
        }
        [path_p release];
    }
#endif
}

void convert_dicdir_to_posix(std::string& dicdir)
{
#if VERSIONMAC
    /* convert HFS to POSIX */
    NSString *path_h = [[NSString alloc]initWithUTF8String:dicdir.c_str()];
    if(path_h)
    {
        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)path_h, kCFURLHFSPathStyle, true);
        if(url)
        {
            NSString *path_p = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
            dicdir = [path_p UTF8String];
            [path_p release];
            [url release];
        }
        [path_h release];
    }
#endif
}

#pragma mark -

void useModel(std::string& dicdir, std::vector<std::string>& userdics)
{
    std::string rcfile;
    GetRcFile(rcfile);
    
    std::string path = "--output-format-type=none\n--rcfile=" + rcfile;
    
    if(dicdir.length() != 0)
    {
        path += "\n--dicdir=";
        path += dicdir;
    }
    
    for(size_t i = 0;i < userdics.size();++i)
    {
        path += "\n--userdic=";
        path += userdics.at(i);
    }
    
    std::lock_guard<std::mutex> lock(mutexModel);
    
    MeCab::Model *model = MeCab::createModel(path.c_str());
    
    if(model)
    {
        if(gModel)
        {
            delete gModel;
        }
        
        gModel = model;
        gModelPath = path;
        
#if VERSIONMAC
        convert_dicdir_to_hfs(dicdir);
        
        for(auto it = userdics.begin() ; it != userdics.end() ; it++)
        {
            std::string userdic = *it;
            convert_userdic_to_hfs(userdic);
            *it = userdic;
        }
#endif
        
        gDicDir = dicdir;
        gUserDics = userdics;
    }
    
}

void clearModel()
{
    std::lock_guard<std::mutex> lock(mutexModel);
    
    if(gModel)
    {
        delete gModel;
    }
    
    gModel = NULL;
    gModelPath.clear();
    gDicDir.clear();
    gUserDics.clear();
}

#pragma mark -

void OnStartup()
{
    std::string dicdir;
    std::vector<std::string> userdics;
    
    std::string dictName;
    
    dictName = DEFAULT_DICNAME;
    GetDictDir(dicdir, dictName);
    
    useModel(dicdir, userdics);
}

void OnExit()
{
    if(gModel)
    {
        clearModel();
    }
}

#pragma mark -

void GetResourceDir(std::string &resourcedir)
{
#if VERSIONMAC
    NSBundle *bundle = [NSBundle bundleWithIdentifier:@"com.4D.mecab-v2"];
    if(bundle)
    {
        resourcedir = (const char *)[[bundle resourcePath]UTF8String];
    }
#else
    
#endif
    resourcedir += '/';
}

void GetRcFile(std::string &rcfile)
{
    GetResourceDir(rcfile);
    
    rcfile += "mecabrc";
}
    
void GetDictDir(std::string& dicdir, std::string& dictName)
{
    GetResourceDir(dicdir);
    
    dicdir = dicdir + "dic/" + dictName;
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :
            OnStartup();
            break;
            
        case kDeinitPlugin :
            OnExit();
            break;
// --- MeCab

		case 1 :
			MeCab_SET_MODEL(pResult, pParams);
			break;

		case 2 :
			MeCab_Get_model(pResult, pParams);
			break;

		case 3 :
			_MeCab(pResult, pParams);
			break;

// --- MeCab Dictionary

		case 4 :
			MeCab_INDEX_DICTIONARY(pResult, pParams);
			break;

		case 5 :
			MeCab_GENERATE_DICTIONARY(pResult, pParams);
			break;

	}
}

// ------------------------------------- MeCab ------------------------------------

#pragma mark -

void convertFromString(std::string &fromString, C_TEXT &toString)
{
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), (LPWSTR)&buf[0], len)){
            CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
            toString.setUTF16String(&u16);
        }
    }else{
        CUTF16String u16 = CUTF16String((const PA_Unichar *)L"\0\0");
        toString.setUTF16String(&u16);
    }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)fromString.c_str(), fromString.length(), kCFStringEncodingUTF8, true);
    if(str){
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        toString.setUTF16String(&u16);
        CFRelease(str);
    }
#endif
}

void convertToString(C_TEXT &fromString, std::string &toString)
{
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), (LPSTR)&buf[0], len, NULL, NULL)){
            toString = std::string((const char *)&buf[0]);
        }
    }else{
        toString = std::string((const char *)"\0");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)fromString.getUTF16StringPtr(), fromString.getUTF16Length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        
        toString = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

#pragma mark -

void MeCab_SET_MODEL(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    std::string options;
    convertToString(Param1, options);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse(options.c_str(),
                               options.c_str() + options.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        std::string dicdir;
        std::vector<std::string> userdics;
        
        for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Json::Value key = it.key();
            JSONCPP_STRING name = it.name();
            
            if(name == "dicdir")
            {
                if(it->isString())
                {
                    dicdir = it->asString();
                }
            }
            else
            if(name == "userdic")
            {
                if(it->isString())
                {
                    std::string userdic = it->asString();
                    userdics.push_back(userdic);
                }else if(it->isArray())
                {
                    for(Json::Value::const_iterator iit = it->begin() ; iit != it->end() ; iit++)
                    {
                        if(iit->isString())
                        {
                            std::string userdic = iit->asString();
                            userdics.push_back(userdic);
                        }
                    }
                }
            }
        }
        if((dicdir.length() != 0) || (userdics.size() != 0))
        {
#if VERSIONMAC
            convert_dicdir_to_posix(dicdir);
            
            for(auto it = userdics.begin() ; it != userdics.end() ; it++)
            {
                std::string userdic = *it;
                convert_userdic_to_posix(userdic);
                *it = userdic;
            }
#endif
            useModel(dicdir, userdics);
        }
    }
}

void MeCab_Get_model(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
    
    Json::Value root;
    
    if(gModel)
    {
        root["dicdir"] = gDicDir;
        root["version"] = gModel->version();
        const MeCab::DictionaryInfo *d = gModel->dictionary_info();
        Json::ArrayIndex i = 0;
        
        for (; d; d = d->next)
        {
            Json::Value dict;
            dict["filename"] = d->filename;
            dict["charset"] = d->charset;
            dict["size"] = d->size;
            dict["type"] = d->type;
            dict["lsize"] = d->lsize;
            dict["rsize"] = d->rsize;
            dict["version"] = d->version;
            root["dict"][i++] = dict;
        }
    }
    
    Json::StyledWriter writer;
    std::string options = writer.write(root);

    convertFromString(options, returnValue);
	returnValue.setReturn(pResult);
}

#pragma mark -

void _MeCab(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
    
    int nbest = 0;
    float theta = 0.0;
    
    if(Param2.getUTF16Length())
    {
        std::string options;
        convertToString(Param2, options);
        
        Json::Value root;
        Json::CharReaderBuilder builder;
        std::string errors;
        
        Json::CharReader *reader = builder.newCharReader();
        bool parse = reader->parse(options.c_str(),
                                   options.c_str() + options.size(),
                                   &root,
                                   &errors);
        delete reader;
        
        if(parse)
        {
            for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
            {
                Json::Value key = it.key();
                JSONCPP_STRING name = it.name();
                
                if(name == "nbest")
                {
                    if(it->isInt())
                    {
                        nbest = it->asInt();
                    }
                }
                if(name == "theta")
                {
                    if(it->isDouble())
                    {
                        theta = it->asDouble();
                    }
                }
            }
        }
    }
    
    Json::Value root;
    
	if(gModel)
    {
        MeCab::Tagger *tagger = gModel->createTagger();
        if(tagger)
        {
            MeCab::Lattice *lattice = gModel->createLattice();
            if(lattice)
            {
                std::string sentence;
                convertToString(Param1, sentence);
                
                if(nbest != 0)
                {
                    lattice->set_request_type(MECAB_NBEST);/* MECAB_ONE_BEST=default */
                }else
                {
                    nbest = 1;
                }

                if(theta != 0)
                {
                    lattice->set_theta(theta);
                }
                
                lattice->set_sentence(sentence.c_str());
                
                if(tagger->parse(lattice))
                {
                    for (Json::ArrayIndex n = 0; n < nbest; ++n)
                    {
                        Json::ArrayIndex i = 0;
                        
                        const char *input = lattice->sentence();
                        
                         const MeCab::Node *node = lattice->bos_node();
                        /* bos = beginning of string, eos = end of string */
                        while(node)
                        {
                            switch(node->stat)
                            {
                                case MECAB_BOS_NODE:
                                case MECAB_EOS_NODE:
                                    break;
                                default:
                                {
                                    Json::Value word;
                                    word["feature"] = node->feature;
                                    word["value"] = sentence.substr((node->surface - input), node->length);
                                    word["rcAttr"] = node->rcAttr;
                                    word["lcAttr"] = node->lcAttr;
                                    word["posid"] = node->posid;
                                    word["char_type"] = node->char_type;
                                    word["stat"] = node->stat;
                                    word["isbest"] = (1 == node->isbest);
                                    word["cost"] = (Json::Int)node->cost;
                                    
                                    /*
                                     word["alpha"] = node->alpha;
                                     word["beta"] = node->beta;
                                     word["prob"] = node->prob;
                                     
                                     word["wcost"] = (Json::Int)node->wcost;
                                     */
                                    
                                    if(lattice->has_request_type(MECAB_NBEST))
                                    {
                                        root[n][i++] = word;
                                    }else
                                    {
                                        root[i++] = word;
                                    }
                                }
                                    break;
                            }
                            node = node->next;
                        }/* node */
                        
                        if(lattice->has_request_type(MECAB_NBEST))
                        {
                            if(!lattice->next())
                            {
                                break;
                            }
                            lattice->next();
                        }
                    }
                }/* tagger->parse(lattice) */
                delete lattice;
            }/* lattice */
            delete tagger;
        }/* tagger */
    }/* gModel */

    Json::StyledWriter writer;
    std::string result = writer.write(root);
    
    convertFromString(result, returnValue);
	returnValue.setReturn(pResult);
}

// ------------------------------- MeCab Dictionary -------------------------------

#pragma mark -

void enum_csv_dictionaries(std::string& path,
                           std::vector<std::string>& dics)
{
    dics.clear();
    
    std::string dicdir = path;
    if(dicdir.length() == 0) dicdir = '/';
    if(dicdir.at(dicdir.size() - 1) != '/') dicdir += '/';
    
#if VERSIONMAC
    NSString *pathString = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, path.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    BOOL isDirectory = YES;
    if([fm fileExistsAtPath:pathString isDirectory:&isDirectory])
    {
        if(isDirectory)
        {
            NSArray *paths = (NSMutableArray *)[fm contentsOfDirectoryAtPath:pathString error:NULL];
            [paths enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)
            {
                NSString *_path = (NSString *)obj;
                if([_path hasSuffix:@"csv"])
                {
                    dics.push_back(dicdir + [_path UTF8String]);
                }
            }];
        }
        [pathString release];
        [fm release];
    }
#else
    C_TEXT t;
    t.setUTF8String((const uint8_t *)path.c_str(), path.length());
    CUTF16String path_w;
    t.copyUTF16String(&path_w);
    WIN32_FIND_DATA find;
    HANDLE h = FindFirstFile(path_w.c_str(), &find);
    if(h != INVALID_HANDLE_VALUE)
    {
         do {
             std::wstring sub_path = find.cFileName;
             /* ignore these meta */
             if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                 continue;
             
             if((find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
             {
                 size_t i = sub_path.rfind(L".", sub_path.length());
                 if (i != std::string::npos)
                 {
                     std::string extension = sub_path.substr(i + 1);
                     if(extension.compare(L"csv" == 0))
                     {
                         C_TEXT p;
                         p.setUTF16String((const PA_Unichar *)sub_path.c_str(), sub_path.length());
                         CUTF8String path_u;
                         p.copyUTF8String(&path_u);
                         dics.push_back(dicdir + (const char *)path_u.c_str());
                     }
                 }
             }
             
         }while (FindNextFile(h, &find));
        FindClose(h);
    }
#endif
}

int toInt(const char *str) {
    if (!str || std::strlen(str) == 0) {
        return INT_MAX;
    }
    return std::atoi(str);
}

const unsigned int DictionaryMagicID = 0xef718f77u;

int calcCost(const std::string &w, const std::string &feature,
             int factor,
             MeCab::DecoderFeatureIndex *fi, MeCab::DictionaryRewriter *rewriter,
             MeCab::CharProperty *property)
{
    if((fi) && (rewriter) && (property))
    {
        MeCab::LearnerPath path;
        MeCab::LearnerNode rnode;
        MeCab::LearnerNode lnode;
        rnode.stat  = lnode.stat = MECAB_NOR_NODE;
        rnode.rpath = &path;
        lnode.lpath = &path;
        path.lnode  = &lnode;
        path.rnode  = &rnode;
        
        size_t mblen = 0;
        const MeCab::CharInfo cinfo = property->getCharInfo(w.c_str(),
                                                            w.c_str() + w.size(),
                                                            &mblen);
        path.rnode->char_type = cinfo.default_type;
        std::string ufeature, lfeature, rfeature;
        rewriter->rewrite2(feature, &ufeature, &lfeature, &rfeature);
        fi->buildUnigramFeature(&path, ufeature.c_str());
        fi->calcCost(&rnode);
        return MeCab::tocost(rnode.wcost, factor);
    }
    
    return 0;
}

int progress_bar_darts(size_t current, size_t total, void *progress_ctx)
{
    progress_ctx_t *ctx = (progress_ctx_t *)progress_ctx;
    
    int cur_percentage  = static_cast<int>(100.0 * current/total);
    int prev = ctx->progress;
    
    if (prev != cur_percentage)
    {
        C_TEXT *Param2_callback = (C_TEXT *)ctx->callback_method;
        
        std::string message;
        
        callback(Param2_callback,
                 callback_event_emit_double_array,
                 message,
                 current,
                 total);
    }
    
    ctx->progress = cur_percentage;

    return 1;
}

template <typename T1, typename T2>
struct pair_1st_cmp: public std::binary_function<bool, T1, T2> {
    bool operator()(const std::pair<T1, T2> &x1,
                    const std::pair<T1, T2> &x2)  {
        return x1.first < x2.first;
    }
};

#define DCONF(file) MeCab::create_filename(dicdir, std::string(file)).c_str()
#define OCONF(file) MeCab::create_filename(outdir, std::string(file)).c_str()

struct Range {
    int low;
    int high;
    std::vector<std::string> c;
};
   
int atohex(const char *s) {
    int n = 0;
    
    if(std::strlen(s) >= 3
       && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
    {
        const char *p = s;
        s += 2;
        while (*s) {
            int r = 0;
            if (*s >= '0' && *s <= '9')
                r = *s - '0';
            else if (*s >= 'A' && *s <= 'F')
                r = *s - 'A' + 10;
            else if (*s >= 'a' && *s <= 'f')
                r = *s - 'a' + 10;
            else
                return 0;
            
            n = 16 * n + r;
            s++;
        }
        
        return n;
    }
    
    return 0;
}

MeCab::CharInfo encode(const std::vector<std::string> &c,
                       std::map<std::string, MeCab::CharInfo> *category) {
    
    if(c.size() == 0)
    {
        return MeCab::CharInfo();
    }
    
    std::map<std::string, MeCab::CharInfo>::const_iterator it = category->find(c[0]);
    
    if(it == category->end())
    {
        return MeCab::CharInfo();
    }
    
    MeCab::CharInfo base = it->second;
    for (size_t i = 0; i < c.size(); ++i) {
        std::map<std::string, MeCab::CharInfo>::const_iterator it =
        category->find(c[i]);
        
        if(it == category->end())
        {
            return MeCab::CharInfo();
        }
        
        base.type += (1 << it->second.default_type);
    }
    
    return base;
}

#pragma mark -

/* MeCab::Connector::compile (connector.cpp) */
bool compile_matrix(const char *ifile,
                       const char *ofile,
                       progress_ctx_t *progress_ctx)
{
    using namespace MeCab;
    
    C_TEXT *Param2_callback = (C_TEXT *)progress_ctx->callback_method;
    
    std::ifstream ifs(WPATH(ifile));/* matrix.def */
    std::istringstream iss(MATRIX_DEF_DEFAULT);
    std::istream *is = &ifs;
    
    if (!ifs)
    {
        if(STDERR_DEBUG_INFO)
        {
            std::cerr
            << ifile
            << " is not found. minimum setting is used."
            << std::endl;
        }
        is = &iss;
    }
    
    char *column[4];
    scoped_fixed_array<char, BUF_SIZE> buf;
    
    is->getline(buf.get(), buf.size());

    if(tokenize2(buf.get(), "\t ", column, 2) != 2)
    {
        std::string message = ifile;
        callback(Param2_callback,
                 callback_event_error_invalid_def_file,
                 message, 0, 0);
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr
            << "format error: "
            << buf.get()
            << std::endl;
        }
        
        return false;
    }
    
    const unsigned short lsize = std::atoi(column[0]);
    const unsigned short rsize = std::atoi(column[1]);
    std::vector<short> matrix(lsize * rsize);
    std::fill(matrix.begin(), matrix.end(), 0);
    
    std::string message = ifile;
    
    callback(Param2_callback,
             callback_event_open_file,
             message, lsize, rsize);
    
    while (is->getline(buf.get(), buf.size()))
    {
        if(tokenize2(buf.get(), "\t ", column, 3) != 3)
        {
            std::string message = ifile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr
                << "format error: "
                << buf.get()
                << std::endl;
            }
            
            return false;
        }

        const size_t l = std::atoi(column[0]);
        const size_t r = std::atoi(column[1]);
        const int    c = std::atoi(column[2]);
        
        
        if(!(l < lsize && r < rsize))
        {
            std::string message = ifile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr
                << "index values are out of range"
                << std::endl;
            }
            
            return false;
        }
        
        
        int cur_percentage  = static_cast<int>(100.0 * (l + 1)/lsize);
        int prev = progress_ctx->progress;
        
        if (prev != cur_percentage)
        {
            std::string message;
            
            callback(Param2_callback,
                     callback_event_emit_matrix,
                     message,
                     (l + 1),
                     lsize);
        }
        
        progress_ctx->progress = cur_percentage;
        
        matrix[(l + lsize * r)] = static_cast<short>(c);
    }
    
    std::ofstream ofs(WPATH(ofile), std::ios::binary|std::ios::out);
    
    if(!ofs)
    {
        std::string message = ofile;
        callback(Param2_callback,
                 callback_event_error_create_file,
                 message, 0, 0);
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "permission denied: " << ofile << std::endl;
        }
        
        return false;
    }
    
    ofs.write(reinterpret_cast<const char*>(&lsize), sizeof(unsigned short));
    ofs.write(reinterpret_cast<const char*>(&rsize), sizeof(unsigned short));
    ofs.write(reinterpret_cast<const char*>(&matrix[0]),
              lsize * rsize * sizeof(short));
    ofs.close();
    
  return true;
}

/* MeCab::CharProperty::compile (char_property.cpp) */
bool compile_char_property(const char *cfile,
                           const char *ufile,
                           const char *ofile,
                           progress_ctx_t *progress_ctx)
{
    using namespace MeCab;
    
    C_TEXT *Param2_callback = (C_TEXT *)progress_ctx->callback_method;
    
    scoped_fixed_array<char, BUF_SIZE> line;
    scoped_fixed_array<char *, 512> col;
    size_t id = 0;
    std::vector<Range> range;
    std::map<std::string, CharInfo> category;
    std::vector<std::string> category_ary;
    std::ifstream ifs(WPATH(cfile));
    std::istringstream iss(CHAR_PROPERTY_DEF_DEFAULT);
    std::istream *is = &ifs;
    
    if(!ifs)
    {
        std::string message = cfile;
        callback(Param2_callback,
                 callback_event_error_open_file,
                 message, 0, 0);
        
        return false;
    }
    
    while (is->getline(line.get(), line.size())) {
        if (std::strlen(line.get()) == 0 || line[0] == '#') {
            continue;
        }
        const size_t size = tokenize2(line.get(), "\t ", col.get(), col.size());
        
        if(size < 2)
        {
            std::string message = cfile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "format error: " << line.get() << std::endl;
            }
            
            return false;
        }
        
        // 0xFFFF..0xFFFF hoge hoge hgoe #
        if (std::strncmp(col[0], "0x", 2) == 0) {
            std::string low = col[0];
            std::string high;
            size_t pos = low.find("..");
            
            if (pos != std::string::npos) {
                high = low.substr(pos + 2, low.size() - pos - 2);
                low  = low.substr(0, pos);
            } else {
                high = low;
            }
            
            Range r;
            r.low = atohex(low.c_str());
            r.high = atohex(high.c_str());
            
            if(r.low >= 0 && r.low < 0xffff &&
               r.high >= 0 && r.high < 0xffff &&
               r.low <= r.high)
            {
                for (size_t i = 1; i < size; ++i) {
                    if (col[i][0] == '#') {
                        break;  // skip comments
                    }
                    
                    if(category.find(std::string(col[i]))  == category.end())
                    {
                        std::string message = cfile;
                        callback(Param2_callback,
                                 callback_event_error_invalid_def_file,
                                 message, 0, 0);
                        
                        if(STDERR_DEBUG_INFO)
                        {
                            std::cerr << "category [" << col[i] << "] is undefined" << std::endl;
                        }
                        
                        return false;
                    }

                    r.c.push_back(col[i]);
                }
                range.push_back(r);
            }else
            {
                std::string message = cfile;
                callback(Param2_callback,
                         callback_event_error_invalid_def_file,
                         message, 0, 0);
                
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr << "range error: low=" << r.low << " high=" << r.high << std::endl;
                }
                
                return false;
            }
  
        } else {
            
            if(size < 4)
            {
                std::string message = cfile;
                callback(Param2_callback,
                         callback_event_error_invalid_def_file,
                         message, 0, 0);
                
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr << "format error: " << line.get() << std::endl;
                }
                
                return false;
            }
            
            std::string key = col[0];
            
            if(category.find(key) != category.end())
            {
                std::string message = cfile;
                callback(Param2_callback,
                         callback_event_error_invalid_def_file,
                         message, 0, 0);
                
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr << "category " << key << " is already defined" << std::endl;
                }
                
                return false;
            }
            
            CharInfo c;
            std::memset(&c, 0, sizeof(c));
            c.invoke  = std::atoi(col[1]);
            c.group   = std::atoi(col[2]);
            c.length  = std::atoi(col[3]);
            c.default_type = id++;
            
            category.insert(std::pair<std::string, CharInfo>(key, c));
            category_ary.push_back(key);
        }
    }
    
    if(category.size() >= 18)
    {
        std::string message = cfile;
        callback(Param2_callback,
                 callback_event_error_invalid_def_file,
                 message, 0, 0);
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "too many categories(>= 18)" << std::endl;
        }
        
        return false;
    }
        
    if(category.find("DEFAULT") == category.end())
    {
        std::string message = cfile;
        callback(Param2_callback,
                 callback_event_error_invalid_def_file,
                 message, 0, 0);
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "category [DEFAULT] is undefined" << std::endl;
        }
        
        return false;
    }
 
    if(category.find("SPACE") == category.end())
    {
        std::string message = cfile;
        callback(Param2_callback,
                 callback_event_error_invalid_def_file,
                 message, 0, 0);
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "category [SPACE] is undefined" << std::endl;
        }
        
        return false;
    }

    std::istringstream iss2(UNK_DEF_DEFAULT);
    std::ifstream ifs2(WPATH(ufile));
    std::istream *is2 = &ifs2;
    
    if (!ifs2) {
        
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << ufile
            << " is not found. minimum setting is used." << std::endl;
            is2 = &iss2;
        }
    }
    
    std::set<std::string> unk;
    
    while (is2->getline(line.get(), line.size())) {
        const size_t n = tokenizeCSV(line.get(), col.get(), 2);
        
        if(n < 1)
        {
            std::string message = cfile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "format error: " << line.get() << std::endl;
            }
            
            return false;
        }
        
        const std::string key = col[0];
        
        if(category.find(key) == category.end())
        {
            std::string message = cfile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "category [" << key << "] is undefined in " << cfile << std::endl;
            }
            
            return false;
            
        }

        unk.insert(key);
    }
    
    for (std::map<std::string, CharInfo>::const_iterator it = category.begin();
         it != category.end();
         ++it) {
        
        if(unk.find(it->first) == unk.end())
        {
            std::string message = cfile;
            callback(Param2_callback,
                     callback_event_error_invalid_def_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "category [" << it->first << "] is undefined in " << ufile << std::endl;
            }
            
            return false;
        }
    }
    
    std::vector<CharInfo> table(0xffff);
    {
        std::vector<std::string> tmp;
        tmp.push_back("DEFAULT");
        const CharInfo c = encode(tmp, &category);
        std::fill(table.begin(), table.end(), c);
    }
    
    for (std::vector<Range>::const_iterator it = range.begin();
         it != range.end();
         ++it) {
        const CharInfo c = encode(it->c, &category);
        for (int i = it->low; i <= it->high; ++i) {
            table[i] = c;
        }
    }
    
    // output binary table
    {
        std::ofstream ofs(WPATH(ofile), std::ios::binary|std::ios::out);
        
        if(!ofs)
        {
            std::string message = ofile;
            callback(Param2_callback,
                     callback_event_error_create_file,
                     message, 0, 0);
            
            return false;
        }
        
        unsigned int size = static_cast<unsigned int>(category.size());
        ofs.write(reinterpret_cast<const char*>(&size), sizeof(size));
        for (std::vector<std::string>::const_iterator it = category_ary.begin();
             it != category_ary.end();
             ++it) {
            char buf[32];
            std::fill(buf, buf + sizeof(buf), '\0');
            std::strncpy(buf, it->c_str(), sizeof(buf) - 1);
            ofs.write(reinterpret_cast<const char*>(buf), sizeof(buf));
        }
        ofs.write(reinterpret_cast<const char*>(&table[0]),
                  sizeof(CharInfo) * table.size());
        ofs.close();
    }
    
    return true;
}

/* MeCab::FeatureIndex::compile (feature_index.cpp) */
bool compile_model(const MeCab::Param &param,
                   const char* txtfile,
                   const char *binfile,
                   progress_ctx_t *progress_ctx)
{
    using namespace MeCab;
    
    C_TEXT *Param2_callback = (C_TEXT *)progress_ctx->callback_method;
    
    std::ifstream ifs(WPATH(txtfile));
    
    if(!ifs)
    {
        std::string message = txtfile;
        callback(Param2_callback,
                 callback_event_error_open_file,
                 message, 0, 0);
        
        return false;
    }
    
    scoped_fixed_array<char, BUF_SIZE> buf;
    char *column[4];
    std::vector<std::pair<uint64_t, double> > dic;
    std::string model_charset;
    
    std::string obuf;
    
    while (ifs.getline(buf.get(), buf.size()))
    {
        if (std::strlen(buf.get()) == 0)
        {
            break;
        }
        
        if(tokenize2(buf.get(), ":", column, 2) != 2)
        {
            std::string message = txtfile;
            callback(Param2_callback,
                     callback_event_error_invalid_model_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "format error: " << buf.get() << std::endl;
            }
            
            return false;
        }
        
        if (std::string(column[0]) == "charset")
        {
            model_charset = column[1] + 1;
        }
    }
    
    std::string from = param.get<std::string>("dictionary-charset");
    std::string to = param.get<std::string>("charset");
    
    if (!from.empty()) {
        
        if(decode_charset(model_charset.c_str())
           != decode_charset(from.c_str()))
        {
            std::string message = txtfile;
            callback(Param2_callback,
                     callback_event_error_invalid_model_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "dictionary charset and model charset are different."
                << "dictionary_charset=" << from
                << " model_charset=" << model_charset << std::endl;
            }
            
            return false;
        }
   
    } else {
        from = model_charset;
    }
    
    if (to.empty()) {
        to = from;
    }
    
    Iconv iconv;
    if(!iconv.open(from.c_str(), to.c_str()))
    {
        return false;
    }
    
    while (ifs.getline(buf.get(), buf.size()))
    {
        if(tokenize2(buf.get(), "\t", column, 2) != 2)
        {
            std::string message = txtfile;
            callback(Param2_callback,
                     callback_event_error_invalid_model_file,
                     message, 0, 0);
            
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "format error: " << buf.get() << std::endl;
            }
            
            return false;
        }
        
        std::string feature = column[1];
        
        if (!iconv.convert(&feature))
        {
            if(STDERR_DEBUG_INFO)
            {
                std::cerr << "iconv conversion failed"
                << std::endl;
            }
            
            return false;
        }else
        {
            const uint64_t fp = fingerprint(feature);
            const double alpha = atof(column[0]);
            dic.push_back(std::pair<uint64_t, double>(fp, alpha));
        }
    }
    
    obuf.clear();
    unsigned int size = static_cast<unsigned int>(dic.size());
    obuf.append(reinterpret_cast<const char*>(&size), sizeof(size));
    
    char charset_buf[32];
    std::fill(charset_buf, charset_buf + sizeof(charset_buf), '\0');
    std::strncpy(charset_buf, to.c_str(), 31);
    obuf.append(reinterpret_cast<const char *>(charset_buf),
                   sizeof(charset_buf));
    
    std::sort(dic.begin(), dic.end());
    
    
    for (size_t i = 0; i < dic.size(); ++i) {
        const double alpha = dic[i].second;
        obuf.append(reinterpret_cast<const char *>(&alpha), sizeof(alpha));
    }
    
    for (size_t i = 0; i < dic.size(); ++i) {
        const uint64_t fp = dic[i].first;
        obuf.append(reinterpret_cast<const char *>(&fp), sizeof(fp));
    }

    std::ofstream ofs(WPATH(binfile), std::ios::binary|std::ios::out);

    if(!ofs)
    {
        std::string message = binfile;
        callback(Param2_callback,
                 callback_event_error_create_file,
                 message, 0, 0);
        
        return false;
    }
    
    ofs.write(obuf.data(), obuf.size());
    
    return true;
}

/* MeCab::Dictionary::compile (dictionary.cpp) */
bool compile_dictionary(const MeCab::Param &param,
                        const std::vector<std::string> &dics,
                        const char *output,
                        progress_ctx_t *progress_ctx)
{
    using namespace MeCab;
    
    C_TEXT *Param2_callback = (C_TEXT *)progress_ctx->callback_method;
    
    Connector matrix;
    scoped_ptr<DictionaryRewriter> rewrite;
    scoped_ptr<POSIDGenerator> posid;
    scoped_ptr<DecoderFeatureIndex> fi;
    scoped_ptr<ContextID> cid;
    scoped_ptr<Writer> writer;
    scoped_ptr<Lattice> lattice;
    scoped_ptr<StringBuffer> os;
    scoped_ptr<CharProperty> property;
    Node node;
    
    const std::string dicdir = param.get<std::string>("dicdir");
    
    const std::string matrix_file     = DCONF(MATRIX_DEF_FILE);
    const std::string matrix_bin_file = DCONF(MATRIX_FILE);
    const std::string left_id_file    = DCONF(LEFT_ID_FILE);
    const std::string right_id_file   = DCONF(RIGHT_ID_FILE);
    const std::string rewrite_file    = DCONF(REWRITE_FILE);
    const std::string pos_id_file     = DCONF(POS_ID_FILE);
    
    std::vector<std::pair<std::string, Token*> > dic;
    
    size_t offset  = 0;
    unsigned int lexsize = 0;
    std::string fbuf;
    
    const std::string from = param.get<std::string>("dictionary-charset");
    const std::string to = param.get<std::string>("charset");
    const bool wakati = param.get<bool>("wakati");
    const int type = param.get<int>("type");
    const std::string node_format = param.get<std::string>("node-format");
    const int factor = param.get<int>("cost-factor");
    
    if(factor <= 0)
    {
        std::string message = DCONF(DICRC);
        callback(Param2_callback,
                 callback_event_error_invalid_rc_file,
                 message, 0, 0);
        
        return false;
    }
    
    std::string config_charset = param.get<std::string>("config-charset");
    if (config_charset.empty())
    {
        config_charset = from;
    }
    
    if(from.empty())
    {
        std::string message = DCONF(DICRC);
        callback(Param2_callback,
                 callback_event_error_invalid_rc_file,
                 message, 0, 0);

        return false;
    }
    
    if(to.empty())
    {
        std::string message = DCONF(DICRC);
        callback(Param2_callback,
                 callback_event_error_invalid_rc_file,
                 message, 0, 0);
        
        return false;
    }
    
    Iconv iconv;
    if(!iconv.open(from.c_str(), to.c_str()))
    {
        return false;
    }
    
    Iconv config_iconv;
    if(!config_iconv.open(config_charset.c_str(), from.c_str()))
    {
        return false;
    }
    
    if (!node_format.empty())
    {
        writer.reset(new Writer);
        lattice.reset(createLattice());
        os.reset(new StringBuffer);
        memset(&node, 0, sizeof(node));
    }
    
    if (!matrix.openText(matrix_file.c_str()) &&
        !matrix.open(matrix_bin_file.c_str()))
    {
        matrix.set_left_size(1);
        matrix.set_right_size(1);
    }

    posid.reset(new POSIDGenerator);
    posid->open(pos_id_file.c_str(), &config_iconv);
    
    std::istringstream iss(UNK_DEF_DEFAULT);
  
    size_t total = 0;
    
    for (size_t i = 0; i < dics.size(); ++i) {
        std::ifstream ifs(WPATH(dics[i].c_str()));
        std::istream *is = &ifs;
        if (!ifs) {
            if (type == MECAB_UNK_DIC) {
                
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr << dics[i]
                    << " is not found. minimum setting is used." << std::endl;
                }

                is = &iss;
            } else {
                if(!ifs)
                {
                    std::string message = dics[i];
                    callback(Param2_callback,
                             callback_event_error_missing_file,
                             message, 0, 0);
                    
                    return false;
                }
            }
        }
        
        std::string message = dics[i];
        callback(Param2_callback,
                 callback_event_open_file,
                 message, 0, 0);
        
        scoped_fixed_array<char, BUF_SIZE> line;
        size_t num = 0;
        
        while (is->getline(line.get(), line.size()))
        {
            char *col[8];
            
            const size_t n = tokenizeCSV(line.get(), col, 5);
            if(n != 5)
            {
                std::string message = line.get();
                callback(Param2_callback,
                         callback_event_error_invalid_csv_file,
                         message, 0, 0);

                return false;
            }
            
            std::string w;
            int lid = 0;
            int rid = 0;
            int cost = 0;
            std::string feature;
            
            w = col[0];
            lid = toInt(col[1]);
            rid = toInt(col[2]);
            cost = toInt(col[3]);
            feature = col[4];
            
            const int pid = posid->id(feature.c_str());
            
            if (cost == INT_MAX) {
                if(type != MECAB_USR_DIC)
                {
                    std::string message = line.get();
                    callback(Param2_callback,
                             callback_event_error_invalid_csv_file,
                             message, 0, 0);
                    
                    return false;
                }
                /* rewrite.def */
                if (!rewrite.get())
                {
                    rewrite.reset(new DictionaryRewriter);
                    rewrite->open(rewrite_file.c_str(), &config_iconv);
                    fi.reset(new DecoderFeatureIndex);
                    
                    const std::string modelfile = param.get<std::string>("model");
                    if(modelfile.length())
                    {
                        if (MeCab::file_exists(DCONF(modelfile)))
                        {
                            if(!fi->open(param))
                            {
                                std::string message = modelfile;
                                callback(Param2_callback,
                                         callback_event_error_open_file,
                                         message, 0, 0);
                                
                                return false;
                            }
                        }
                    }else
                    {
                        std::string message = "model";
                        callback(Param2_callback,
                                 callback_event_error_missing_file,
                                 message, 0, 0);
                        
                        return false;
                    }

                    property.reset(new CharProperty);
                    
                    if (MeCab::file_exists(DCONF(CHAR_PROPERTY_FILE)))
                    {
                        if(!property->open(param))
                        {
                            std::string message = CHAR_PROPERTY_FILE;
                            callback(Param2_callback,
                                     callback_event_error_open_file,
                                     message, 0, 0);
                            
                            return false;
                        }
                    }else
                    {
                        std::string message = CHAR_PROPERTY_FILE;
                        callback(Param2_callback,
                                 callback_event_error_missing_file,
                                 message, 0, 0);
                        
                        return false;
                    }
 
                    property->set_charset(from.c_str());
                }
                cost = calcCost(w, feature, factor,
                                fi.get(), rewrite.get(), property.get());
            }
            
            if (lid < 0  || rid < 0 || lid == INT_MAX || rid == INT_MAX) {
                if (!rewrite.get()) {
                    rewrite.reset(new DictionaryRewriter);
                    rewrite->open(rewrite_file.c_str(), &config_iconv);
                }
                
                std::string ufeature, lfeature, rfeature;
                
                if(!rewrite->rewrite(feature, &ufeature, &lfeature, &rfeature))
                {
                    std::string message = rewrite_file;
                    callback(Param2_callback,
                             callback_event_error_write_file,
                             message, 0, 0);

                    return false;
                }
                
                if (!cid.get()) {
                    cid.reset(new ContextID);
                    cid->open(left_id_file.c_str(),
                              right_id_file.c_str(), &config_iconv);
                    
                    if(!(cid->left_size()  == matrix.left_size() && cid->right_size() == matrix.right_size()))
                    {
                        if(STDERR_DEBUG_INFO)
                        {
                            std::cerr << "Context ID files may be broken"
                            << std::endl;
                        }

                        return false;
                    }
                }
                
                lid = cid->lid(lfeature.c_str());
                rid = cid->rid(rfeature.c_str());
   
            }
            
            if((lid == -1) && (rid == -1))
            {
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr
                    << "dummy lid="
                    << lid
                    << " rid="
                    << rid
                    << std::endl;
                }
                
                continue;
                
            }else
            {
                if(!(lid >= 0 && rid >= 0 && matrix.is_valid(lid, rid)))
                {
                    if(STDERR_DEBUG_INFO)
                    {
                        std::cerr << "invalid ids are found"
                        << std::endl;
                    }
                    
                    return false;
                }
                
                if (w.empty()) {
                    std::cerr << "empty word is found, discard this line" << std::endl;
                    continue;
                }
                
                if (!iconv.convert(&feature)) {
                    if(STDERR_DEBUG_INFO)
                    {
                        std::cerr << "iconv conversion failed. skip this entry"
                        << std::endl;
                    }
                    
                    continue;
                }
                
                if (type != MECAB_UNK_DIC && !iconv.convert(&w)) {
                    if(STDERR_DEBUG_INFO)
                    {
                        std::cerr << "iconv conversion failed. skip this entry"
                        << std::endl;
                    }
                    
                    continue;
                }
                
                if (!node_format.empty()) {
                    node.surface = w.c_str();
                    node.feature = feature.c_str();
                    node.length  = w.size();
                    node.rlength = w.size();
                    node.posid   = pid;
                    node.stat    = MECAB_NOR_NODE;
                    lattice->set_sentence(w.c_str());
                    
                    if(!os.get())
                    {
                        
                        if(STDERR_DEBUG_INFO)
                        {
                            std::cerr << "StringBuffer error"
                            << std::endl;
                        }
                        
                        return false;
                    }
                    
                    if(!writer.get())
                    {
                        if(STDERR_DEBUG_INFO)
                        {
                            std::cerr << "Writer error"
                            << std::endl;
                        }
                        
                        return false;
                    }
                    
                    os->clear();
                    
                    if(!(writer->writeNode(lattice.get(),
                                           node_format.c_str(),
                                           &node, &*os)))
                    {
                        if(STDERR_DEBUG_INFO)
                        {
                            std::cerr << "conversion error"
                            << std::endl;
                        }
                        
                        return false;
                    }
                    
                    *os << '\0';
                    feature = os->str();
                }
                
                std::string key;
                if (!wakati) {
                    key = feature + '\0';
                }
                
                if(STDERR_DEBUG_FEATURE)
                {
                    std::cerr << w << ':' << key
                    << std::endl;
                }
                
                Token* token  = new Token;
                token->lcAttr = lid;
                token->rcAttr = rid;
                token->posid  = pid;
                token->wcost = cost;
                token->feature = offset;
                token->compound = 0;
                dic.push_back(std::pair<std::string, Token*>(w, token));
                
                // append to output buffer
                if (!wakati) {
                    fbuf.append(key.data(), key.size());
                }
                
                offset += key.size();
                
                ++num;
                ++lexsize;
                
            }
            
        }/* while */
        
        total += num;

    }/* for */
    
    if(!total)
    {
        return false;
    }
    
    if (wakati) {
        fbuf.append("\0", 1);
    }
    
    std::stable_sort(dic.begin(), dic.end(),
                     pair_1st_cmp<std::string, Token *>());
    
    size_t bsize = 0;
    size_t idx = 0;
    std::string prev;
    std::vector<const char *> str;
    std::vector<size_t> len;
    std::vector<Darts::DoubleArray::result_type> val;
    
    
    for (size_t i = 0; i < dic.size(); ++i) {
        if (i != 0 && prev != dic[i].first) {
            str.push_back(dic[idx].first.c_str());
            len.push_back(dic[idx].first.size());
            val.push_back(bsize +(idx << 8));
            
            if(STDERR_DEBUG_WORD)
            {
                std::cerr << dic[idx].first.c_str()
                << std::endl;
            }
            
            bsize = 1;
            idx = i;
        } else {
            
            ++bsize;
            
        }
        prev = dic[i].first;
    }
    str.push_back(dic[idx].first.c_str());
    len.push_back(dic[idx].first.size());
    val.push_back(bsize +(idx << 8));
    
    if(STDERR_DEBUG_WORD)
    {
        std::cerr << dic[idx].first.c_str()
        << std::endl;
    }
    
    if(str.size() != len.size())
    {
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "str.size() != len.size()"
            << std::endl;
        }

        return false;
    }
    
    if(str.size() != val.size())
    {
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "str.size() != val.size()"
            << std::endl;
        }

        return false;
    }
    
    Darts::DoubleArray da;
    
    if(da.build(str.size(), const_cast<char **>(&str[0]), &len[0], &val[0], &progress_bar_darts, progress_ctx) != 0)
    {
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "unknown error in building double-array"
            << std::endl;
        }

        return false;
    }

    std::string tbuf;
    for (size_t i = 0; i < dic.size(); ++i) {
        tbuf.append(reinterpret_cast<const char*>(dic[i].second),
                    sizeof(Token));
        delete dic[i].second;
    }
    
    dic.clear();

    // needs to be 8byte(64bit) aligned
    while (tbuf.size() % 8 != 0) {
        Token dummy;
        memset(&dummy, 0, sizeof(Token));
        tbuf.append(reinterpret_cast<const char*>(&dummy), sizeof(Token));
    }
        
    unsigned int dummy = 0;
    unsigned int lsize = matrix.left_size();
    unsigned int rsize = matrix.right_size();
    unsigned int dsize = da.unit_size() * da.size();
    unsigned int tsize = tbuf.size();
    unsigned int fsize = fbuf.size();
    
    unsigned int version = DIC_VERSION;
    char charset[32];
    std::fill(charset, charset + sizeof(charset), '\0');
    std::strncpy(charset, to.c_str(), 31);
    
    std::ofstream bofs(WPATH(output), std::ios::binary|std::ios::out);
    
    if(!bofs)
    {
        std::string message = output;
        callback(Param2_callback,
                 callback_event_error_create_file,
                 message, 0, 0);
        
        return false;
    }
    
    unsigned int magic = 0;
    
    // needs to be 64bit aligned
    // 10*32 = 64*5
    bofs.write(reinterpret_cast<const char *>(&magic),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&version), sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&type),    sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&lexsize), sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&lsize),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&rsize),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&dsize),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&tsize),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&fsize),   sizeof(unsigned int));
    bofs.write(reinterpret_cast<const char *>(&dummy),   sizeof(unsigned int));
    
    // 32 * 8 = 64 * 4
    bofs.write(reinterpret_cast<const char *>(charset), sizeof(charset));
    bofs.write(reinterpret_cast<const char*>(da.array()), da.unit_size() * da.size());
    bofs.write(const_cast<const char *>(tbuf.data()), tbuf.size());
    bofs.write(const_cast<const char *>(fbuf.data()), fbuf.size());
    
    // save magic id
    magic = static_cast<unsigned int>(bofs.tellp());
    magic ^= DictionaryMagicID;
    bofs.seekp(0);
    bofs.write(reinterpret_cast<const char *>(&magic), sizeof(unsigned int));
    
    bofs.close();
    
    return true;
}

/* MeCab::Dictionary::assignUserDictionaryCosts (dictionary.cpp) */
bool compile_dictionary_auto(const MeCab::Param &param,
                        const std::vector<std::string> &dics,
                        const char *output,
                        progress_ctx_t *progress_ctx)
{
    using namespace MeCab;
    
    C_TEXT *Param2_callback = (C_TEXT *)progress_ctx->callback_method;
    
    Connector matrix;
    DictionaryRewriter rewriter;
    DecoderFeatureIndex fi;
    ContextID cid;
    CharProperty property;
    
    const std::string dicdir = param.get<std::string>("dicdir");
    
    const std::string matrix_file     = DCONF(MATRIX_DEF_FILE);
    const std::string matrix_bin_file = DCONF(MATRIX_FILE);
    const std::string left_id_file    = DCONF(LEFT_ID_FILE);
    const std::string right_id_file   = DCONF(RIGHT_ID_FILE);
    const std::string rewrite_file    = DCONF(REWRITE_FILE);
    
    const std::string from = param.get<std::string>("dictionary-charset");
    
    const int factor = param.get<int>("cost-factor");
    
    if(factor <= 0)
    {
        std::string message = DCONF(DICRC);
        callback(Param2_callback,
                 callback_event_error_invalid_rc_file,
                 message, 0, 0);
        
        return false;
    }
    
    std::string config_charset = param.get<std::string>("config-charset");
    if (config_charset.empty())
    {
        config_charset = from;
    }
    
    if(from.empty())
    {
        std::string message = DCONF(DICRC);
        callback(Param2_callback,
                 callback_event_error_invalid_rc_file,
                 message, 0, 0);
        
        return false;
    }
    
    Iconv config_iconv;
    if(!config_iconv.open(config_charset.c_str(), from.c_str()))
    {
        return false;
    }
    
    rewriter.open(rewrite_file.c_str(), &config_iconv);

    const std::string modelfile = param.get<std::string>("model");
    if(!modelfile.length())
    {
        std::string message = "model";
        callback(Param2_callback,
                 callback_event_error_missing_file,
                 message, 0, 0);
        
        return false;
    }
    
    if (!MeCab::file_exists(modelfile.c_str()))
    {
        std::string message = modelfile;
        callback(Param2_callback,
                 callback_event_error_missing_file,
                 message, 0, 0);
        
        return false;
    }
    
    if(!MeCab::file_exists(DCONF(FEATURE_FILE)))
    {
        std::string message = DCONF(FEATURE_FILE);
        callback(Param2_callback,
                 callback_event_error_open_file,
                 message, 0, 0);
        
        return false;
    }
    
    if(!fi.open(param))
    {
        return false;
    }
    
    if (!MeCab::file_exists(DCONF(CHAR_PROPERTY_FILE)))
    {
        std::string message = DCONF(CHAR_PROPERTY_FILE);
        callback(Param2_callback,
                 callback_event_error_missing_file,
                 message, 0, 0);
        
        return false;
    }
    
    if (!MeCab::file_exists(rewrite_file.c_str()))
    {
        std::string message = rewrite_file;
        callback(Param2_callback,
                 callback_event_error_missing_file,
                 message, 0, 0);
        
        return false;
    }
    
    if(!property.open(param))
    {
        return false;
    }
    
    property.set_charset(from.c_str());
    
    if (!matrix.openText(matrix_file.c_str()) &&
        !matrix.open(matrix_bin_file.c_str())) {
        matrix.set_left_size(1);
        matrix.set_right_size(1);
    }
    
    cid.open(left_id_file.c_str(),
             right_id_file.c_str(), &config_iconv);
    
    if(!(cid.left_size()  == matrix.left_size() &&
         cid.right_size() == matrix.right_size()))
    {
        if(STDERR_DEBUG_INFO)
        {
            std::cerr << "Context ID files("
            << left_id_file
            << " or "
            << right_id_file
            << " may be broken: "
            << cid.left_size()
            << " "
            << matrix.left_size()
            << " "
            << cid.right_size()
            << " "
            << matrix.right_size()
            << std::endl;
        }
        
        return false;
    }
    
    std::ofstream ofs(output);
    
    if(!ofs)
    {
        std::string message = output;
        callback(Param2_callback,
                 callback_event_error_create_file,
                 message, 0, 0);
        
        return false;
    }
    
    for (size_t i = 0; i < dics.size(); ++i) {
        std::ifstream ifs(WPATH(dics[i].c_str()));
        
        if(!ifs)
        {
            std::string message = dics[i];
            callback(Param2_callback,
                     callback_event_error_missing_file,
                     message,
                     0,
                     0);
            
            return false;
        }
        
        std::string message = dics[i];
        callback(Param2_callback,
                 callback_event_open_file,
                 message,
                 0,
                 0);
        
        scoped_fixed_array<char, BUF_SIZE> line;
        while (ifs.getline(line.get(), line.size()))
        {
            char *col[8];
            const size_t n = tokenizeCSV(line.get(), col, 5);
            
            if(n != 5)
            {
                std::string message = line.get();
                callback(Param2_callback,
                         callback_event_error_invalid_csv_file,
                         message, 0, 0);
                
                return false;
            }
            
            std::string w = col[0];
            const std::string feature = col[4];
            const int cost = calcCost(w, feature, factor,
                                      &fi, &rewriter, &property);
            std::string ufeature, lfeature, rfeature;

            if(!(rewriter.rewrite2(feature, &ufeature, &lfeature, &rfeature)))
            {
                std::string message =feature;
                callback(Param2_callback,
                         callback_event_error_write_file,
                         message, 0, 0);
                
                return false;
            }
            
            const int lid = cid.lid(lfeature.c_str());
            const int rid = cid.rid(rfeature.c_str());
            
            if((lid == -1) && (rid == -1))
            {
                if(STDERR_DEBUG_INFO)
                {
                    std::cerr
                    << "dummy lid="
                    << lid
                    << " rid="
                    << rid
                    << std::endl;
                }
                
            }else
            {
                if(!(lid >= 0 && rid >= 0 && matrix.is_valid(lid, rid)))
                {
                    if(STDERR_DEBUG_INFO)
                    {
                        std::cerr
                        << "invalid ids are found lid="
                        << lid
                        << " rid="
                        << rid
                        << std::endl;
                    }
                    
                    return false;
                }
                
                escape_csv_element(&w);
                
                ofs << w << ',' << lid << ',' << rid << ','
                << cost << ',' << feature << '\n';
            }
        }
    }
    
    return true;
}
#pragma mark -

BOOL callback(C_TEXT *Param2_callback,
              callback_event_t event_t,
              std::string& message,
              size_t current,
              size_t total)
{
    BOOL shouldAbort = false;
    
    if(Param2_callback->getUTF16Length())
    {
        PA_Variable    params[6];
        params[0] = PA_CreateVariable(eVK_Unistring);/* method name */
        params[1] = PA_CreateVariable(eVK_Boolean);/* return value */
        params[2] = PA_CreateVariable(eVK_Unistring);/* $1 */
        params[3] = PA_CreateVariable(eVK_Longint);  /* $2 */
        params[4] = PA_CreateVariable(eVK_Longint);  /* $3 */
        params[5] = PA_CreateVariable(eVK_Longint);  /* $4 */
        
        /* method name */
        PA_SetUnistring((&(params[0].uValue.fString)),
                        (PA_Unichar *)Param2_callback->getUTF16StringPtr());

        /* $0 */
        PA_SetBooleanVariable(&params[1], false);
        
        /* $1 */
        C_TEXT t;
        t.setUTF8String((const uint8_t *)message.c_str(), message.length());
        PA_SetUnistring((&(params[2].uValue.fString)),
                        (PA_Unichar *)t.getUTF16StringPtr());
        
        /* $2, $3, $4 */
        PA_SetLongintVariable(&params[3], event_t);
        PA_SetLongintVariable(&params[4], current);
        PA_SetLongintVariable(&params[5], total);

        PA_ExecuteCommandByID(1007, params, 6);
        shouldAbort = PA_GetBooleanVariable(params[1]);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        PA_ClearVariable(&params[3]);
        PA_ClearVariable(&params[4]);
        PA_ClearVariable(&params[5]);
    }
    
    return shouldAbort;
}

void MeCab_INDEX_DICTIONARY(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_params;
	C_TEXT Param2_callback;

	Param1_params.fromParamAtIndex(pParams, 1);
	Param2_callback.fromParamAtIndex(pParams, 2);

    progress_ctx_t ctx;
    ctx.progress = 0;
    ctx.callback_method = &Param2_callback;
    
    std::string options;
    convertToString(Param1_params, options);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse(options.c_str(),
                               options.c_str() + options.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        std::string dicdir;
        std::string outdir;
        std::string userdic;
        std::string userdicdir;
        std::string sysdicdir;
        std::string model;
        
        std::string dictionaryCharset = "EUC-JP";
        std::string configCharset = "EUC-JP";
        
        bool buildUnknown = false;
        bool buildMatrix = false;
        bool buildCharCategory = false;
        bool buildSysdic = true;
        bool buildModel = false;
        bool assignUserDictionaryCosts = false;
        
        for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Json::Value key = it.key();
            JSONCPP_STRING name = it.name();
            
            if(name == "dicdir")/* d */
            {
            if(it->isString())
            {
            dicdir = it->asString();
            }
            }else
            if(name == "userdicdir")/* custom */
            {
            if(it->isString())
            {
            userdicdir = it->asString();
            }
            }else
                if(name == "sysdicdir")/* custom */
                {
                    if(it->isString())
                    {
                        sysdicdir = it->asString();
                    }
                }else
            if(name == "outdir")/* o */
            {
            if(it->isString())
            {
            outdir = it->asString();
            }
            }else
            if(name == "userdic")/* u */
            {
            if(it->isString())
            {
            userdic = it->asString();
            }
            }else
            if(name == "model")/* m */
            {
            if(it->isString())
            {
            model = it->asString();
            }
            }else
            if(name == "dictionaryCharset")
            {
            if(it->isString())
            {
                std::string t = it->asString();
                if((t.compare("UTF-8") == 0)
                ||(t.compare("utf-8") == 0))
                {
                t = "utf8";
                }
                if(  (t.compare("SHIFT-JIS") == 0)
                   ||(t.compare("SHIFT_JIS") == 0)
                   ||(t.compare("shift-jis") == 0)
                   ||(t.compare("shift_jis") == 0))
                {
                    t = "sjis";
                }
            if(   (t.compare("utf8") == 0)
                ||(t.compare("sjis") == 0)
                ||(t.compare("EUC-JP") == 0))
            {
            dictionaryCharset = t;
            }
            }
            }else
            if(name == "configCharset")
            {
            if(it->isString())
            {
                std::string t = it->asString();
                if(  (t.compare("UTF-8") == 0)
                   ||(t.compare("utf-8") == 0))
                {
                    t = "utf8";
                }
                if(  (t.compare("SHIFT-JIS") == 0)
                   ||(t.compare("SHIFT_JIS") == 0)
                   ||(t.compare("shift-jis") == 0)
                   ||(t.compare("shift_jis") == 0))
                {
                    t = "sjis";
                }
            if(   (t.compare("utf8") == 0)
                ||(t.compare("sjis") == 0)
                ||(t.compare("EUC-JP") == 0))
            {
            configCharset = t;
            }
            }
            }else
            if(name == "assignUserDictionaryCosts")
            {
            if(it->isBool())
            {
            assignUserDictionaryCosts = it->asBool();
            }
            }else
            if(name == "buildUnknown")
            {
            if(it->isBool())
            {
            buildUnknown = it->asBool();
            }
            }else
            if(name == "buildMatrix")
            {
            if(it->isBool())
            {
            buildMatrix = it->asBool();
            }
            }else
            if(name == "buildCharCategory")
            {
            if(it->isBool())
            {
            buildCharCategory = it->asBool();
            }
            }else
            if(name == "buildSysdic")
            {
            if(it->isBool())
            {
            buildSysdic = it->asBool();
            }
            }else
            if(name == "buildModel")
            {
            if(it->isBool())
            {
            buildModel = it->asBool();
            }
            }
        } /* for */
        
        /* start here */
        if(dicdir.length() != 0) /* dicdir is mandatory in both cases */
        {
#if VERSIONMAC
            convert_dicdir_to_posix(dicdir);
#endif
            MeCab::Param param;
            /* load params from dicrc */
            if(!param.load(DCONF(DICRC)))
            {
                std::string message = DICRC;
                callback(&Param2_callback,
                         callback_event_error_missing_file,
                         message,
                         0,
                         0);
            }else
            {
                std::string message = DICRC;
                callback(&Param2_callback,
                         callback_event_open_file,
                         message,
                         0,
                         0);
                
                /* charsets */
                param.set("charset", std::string("utf8"));/* to */
                param.set("dictionary-charset", dictionaryCharset);/* from */
                param.set("config-charset", configCharset);/* default=from */
                
                /* other */
                param.set("wakati", false);
                
                /* paths */
                param.set("dicdir", dicdir);
                param.set("outdir", outdir);
                
#if VERSIONMAC
                convert_userdic_to_posix(model);
#endif
                
                param.set("model", model);
                
                /* get csv files in dicdir (full posix path, please) */
                std::vector<std::string> dic;
                
                if((userdic.length() != 0) && (userdicdir.length() != 0)) /* user dic */
                {
#if VERSIONMAC
                    convert_dicdir_to_posix(userdicdir);
                    convert_userdic_to_posix(userdic);
#endif
                    enum_csv_dictionaries(userdicdir, dic);
                    /* userdic specified */
                    if(dic.size() != 0)
                    {
                        param.set("type", static_cast<int>(MECAB_USR_DIC));
                        
                        if (assignUserDictionaryCosts)
                        {
                            param.set("model", DCONF(MODEL_FILE));
                            
                            if(compile_dictionary_auto(param, dic, userdic.c_str(), &ctx))
                            {
                                std::string message = userdic.c_str();
                                callback(&Param2_callback,
                                         callback_event_create_file,
                                         message,
                                         0,
                                         0);
                            }

                        } else {
                            
                            if(compile_dictionary(param, dic, userdic.c_str(), &ctx))
                            {
                                std::string message = userdic.c_str();
                                callback(&Param2_callback,
                                         callback_event_create_file,
                                         message,
                                         0,
                                         0);
                            }
                        }
                    }else{
                        
                        std::string message = userdicdir;
                        callback(&Param2_callback,
                                 callback_event_error_missing_csv_files,
                                 message,
                                 0,
                                 0);
                    }
   
                }else
                    if((sysdicdir.length() != 0) && (outdir.length() != 0)) /* sys dic */
                    {
#if VERSIONMAC
                        convert_dicdir_to_posix(sysdicdir);
                        convert_dicdir_to_posix(outdir);
#endif
                        enum_csv_dictionaries(sysdicdir, dic);
                        
                        if (buildCharCategory || buildUnknown)
                        {
                            if(compile_char_property(DCONF(CHAR_PROPERTY_DEF_FILE),
                                                  DCONF(UNK_DEF_FILE),
                                                  OCONF(CHAR_PROPERTY_FILE), &ctx))
                            {
                                std::string message = OCONF(CHAR_PROPERTY_FILE);
                                callback(&Param2_callback,
                                         callback_event_create_file,
                                         message,
                                         0,
                                         0);
                            }
                        }
                        
                        if (buildUnknown)
                        {
                            std::vector<std::string> tmp;
                            tmp.push_back(DCONF(UNK_DEF_FILE));
                            param.set("type", static_cast<int>(MECAB_UNK_DIC));
                            
                            if(compile_dictionary(param, dic, OCONF(UNK_DIC_FILE), &ctx))
                            {
                                std::string message = OCONF(UNK_DIC_FILE);
                                callback(&Param2_callback,
                                         callback_event_create_file,
                                         message,
                                         0,
                                         0);
                            }
                        }
                        
                        if (buildModel)
                        {
                            if (MeCab::file_exists(DCONF(MODEL_DEF_FILE)))
                            {
                                if(compile_model(param,
                                                 DCONF(MODEL_DEF_FILE),
                                                 OCONF(MODEL_FILE), &ctx))
                                {
                                    std::string message = OCONF(MODEL_FILE);
                                    callback(&Param2_callback,
                                             callback_event_create_file,
                                             message,
                                             0,
                                             0);
                                }
                            } else {
                                if(STDERR_DEBUG_INFO)
                                {
                                    std::cerr << DCONF(MODEL_DEF_FILE) << " is not found. skipped."
                                    << std::endl;
                                }
                            }
                        }
                        
                        if (buildSysdic)
                        {
                            if(dic.size() == 0)
                            {
                                
                                std::string message = userdicdir;
                                callback(&Param2_callback,
                                         callback_event_error_missing_csv_files,
                                         message,
                                         0,
                                         0);
                                
                            }else
                            {
                                param.set("type", static_cast<int>(MECAB_SYS_DIC));
                                
                                if(compile_dictionary(param, dic, OCONF(SYS_DIC_FILE), &ctx))
                                {
                                    std::string message = OCONF(SYS_DIC_FILE);
                                    callback(&Param2_callback,
                                             callback_event_create_file,
                                             message,
                                             0,
                                             0);
                                }
                            }
                        }
                        
                        if (buildMatrix)
                        {
                            if (MeCab::file_exists(DCONF(MATRIX_DEF_FILE)))
                            {
                                if(compile_matrix(DCONF(MATRIX_DEF_FILE), OCONF(MATRIX_FILE), &ctx))
                                {
                                    std::string message = OCONF(MATRIX_FILE);
                                    callback(&Param2_callback,
                                             callback_event_create_file,
                                             message,
                                             0,
                                             0);
                                }
                            }else
                            {
                                if(STDERR_DEBUG_INFO)
                                {
                                    std::cerr << DCONF(MATRIX_DEF_FILE) << " is not found. skipped."
                                    << std::endl;
                                }
                            }
                        }
                    }
            }
        }
    }/* parse */
}

void MeCab_GENERATE_DICTIONARY(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	// --- write the code of MeCab_GENERATE_DICTIONARY here...

}

